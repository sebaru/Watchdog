/**********************************************************************************************************/
/* Watchdogd/TraductionDLS/ligne.y        Définitions des ligne dls DLS                                   */
/* Projet WatchDog version 2.0       Gestion d'habitat                      dim 10 aoû 2003 08:26:07 CEST */
/* Auteur: LEFEVRE Sebastien                                                                              */
/**********************************************************************************************************/

%{
#include <stdio.h>
#include <string.h>
#include <glib.h>
#include "Proto_traductionDLS.h"
#include "lignes.h"

extern int ligne_source_dls;                           /* Compteur du numero de ligne_source_dls en cours */
int erreur;                                                             /* Compteur d'erreur du programme */
#define  NON_DEFINI        "Ligne %d: %s is not defined\n"
#define  DEJA_DEFINI       "Ligne %d: %s is already defined\n"
#define  INTERDIT_GAUCHE   "Ligne %d: %s interdit en position CONDITION\n"
#define  INTERDIT_DROITE   "Ligne %d: %s interdit en position ACTION\n"
#define  ERR_SYNTAXE       "Ligne %d: Erreur de syntaxe -> %s\n"
%}

%union { int val;
         char *chaine;
         struct ACTION *action;
       }

%token <val>     ROUGE VERT BLEU JAUNE NOIR BLANC ORANGE GRIS
%token <val>     ENTIER
%token <val>     BI MONO ENTREE    /* Uniquement en condition */
%token <val>     TEMPO             /* Condition et action */
%token <val>     MSG ICONE SORTIE  /* Uniquement action */
%token <chaine>  ID

%type  <val>     barre alias_bit couleur modulateur option_entier option_couleur
%type  <chaine>  unite facteur expr
%type  <action>  action une_action

%token   PVIRGULE VIRGULE DONNE EQUIV POINT DPOINT MOINS POUV PFERM
%token   CONTACTEUR FENETRE
%token   HEURE APRES AVANT

%token   OU ET BARRE
%%
fichier: ligne_source_dls;

ligne_source_dls:         listeAlias listeInstr
                        | listeInstr
                        |
                        ;

/************************************************* Gestion des alias **************************************/
listeAlias:     un_alias listeAlias
                | un_alias          {{ Emettre_init_alias(); }}
                ;
                
un_alias:       ID EQUIV barre alias_bit ENTIER PVIRGULE
                {{ char *chaine;
                   int taille;
                   if ( New_alias($1, $4, $5, $3) == FALSE )                            /* Deja defini ? */
                    { taille = strlen($1) + strlen(DEJA_DEFINI) + 1;
                      chaine = New_chaine(taille);
                      g_snprintf( chaine, taille, DEJA_DEFINI, ligne_source_dls, $1 );
                      Emettre_erreur(chaine); g_free(chaine);
                      erreur++;
                    }
                   if ( $4==ENTREE || $4==BI || $4==MONO) /* Optimisation des bits par util. de variable */
                    { taille = strlen($1)+10;
                      chaine = New_chaine(taille);
                      g_snprintf( chaine, taille, "int %s;\n", $1 );
                      Emettre(chaine); g_free(chaine);
                    }
                }}
                | ID EQUIV ICONE ENTIER PVIRGULE
                {{ char *chaine;
                   int taille;
                   if (New_alias($1, $3, $4, 0) == FALSE)
                    { taille = strlen($1) + strlen(DEJA_DEFINI) + 1;
                      chaine = New_chaine(taille);
                      g_snprintf( chaine, taille, DEJA_DEFINI, ligne_source_dls, $1 );
                      Emettre_erreur(chaine); g_free(chaine);
                      erreur++;
                    }
                }}
                | ID EQUIV TEMPO ENTIER DPOINT ENTIER PVIRGULE
                {{ char *chaine;
                   int taille;
                   if (New_alias($1, $3, $4, $6) == FALSE)
                    { taille = strlen($1) + strlen(DEJA_DEFINI) + 1;
                      chaine = New_chaine(taille);
                      g_snprintf( chaine, taille, DEJA_DEFINI, ligne_source_dls, $1 );
                      Emettre_erreur(chaine); g_free(chaine);
                      erreur++;
                    }
                }}
                ;
alias_bit:      BI | MONO | ENTREE | SORTIE | MSG
                ;
/******************************************* Gestion des instructions *************************************/
listeInstr:     une_instr listeInstr
                | une_instr
                ;

une_instr:      MOINS expr DONNE action PVIRGULE
                {{ int taille;
                   char *instr;
                   taille = strlen($2)+strlen($4->alors)+11;
                   if ($4->sinon)
                    { taille += (strlen($4->sinon) + 10);
                      instr = New_chaine( taille );
                      g_snprintf( instr, taille, "if(%s) { %s }\nelse { %s }\n", $2, $4->alors, $4->sinon );
                    }
                   else
                    { instr = New_chaine( taille );
                      g_snprintf( instr, taille, "if(%s) { %s }\n", $2, $4->alors );
                    }

                   Emettre( instr ); g_free(instr);
                   if ($4->sinon) g_free($4->sinon); 
                   g_free($4->alors); g_free($4);
                   g_free($2);
                }}

/******************************************* Gestion des contacteurs **************************************/
                | MOINS CONTACTEUR POUV  ENTREE ENTIER VIRGULE ENTREE ENTIER VIRGULE ENTREE ENTIER
                  VIRGULE SORTIE ENTIER VIRGULE SORTIE ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER
                  VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER
                  VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER
                  VIRGULE MSG ENTIER VIRGULE MONO ENTIER VIRGULE MONO ENTIER VIRGULE MONO ENTIER
                  VIRGULE MONO ENTIER VIRGULE MONO ENTIER VIRGULE MONO ENTIER VIRGULE BI ENTIER 
                  VIRGULE BI ENTIER VIRGULE BI ENTIER VIRGULE BI ENTIER VIRGULE BI ENTIER 
                  VIRGULE BI ENTIER VIRGULE BI ENTIER VIRGULE TEMPO ENTIER VIRGULE TEMPO ENTIER
                  VIRGULE ICONE ENTIER VIRGULE ICONE ENTIER VIRGULE ICONE ENTIER VIRGULE ICONE ENTIER
                  VIRGULE ICONE ENTIER VIRGULE ICONE ENTIER VIRGULE ICONE ENTIER VIRGULE ICONE ENTIER
                  VIRGULE ICONE ENTIER
                  PFERM PVIRGULE
                {{ int taille;
                   char *instr;
                   taille = 300;
                   instr = New_chaine( taille );
                   g_snprintf( instr, taille, "Gerer_contacteur("
                                           "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,"
                                           "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d);",
                                            $5, $8, $11, $14, $17, $20, $23, $26, $29, $32, $35, $38, $41,
                                            $44, $47, $50, $53, $56, $59, $62, $65, $68, $71, $74, $77,
                                            $80, $83, $86, $89, $92, $95, $98, $101, $104, $107, $110, $113,
                                            $116, $119, $122 );
                   Emettre( instr ); g_free(instr);
                }}
/*************************************** Module de gestion des fenetres ***********************************/
                | MOINS FENETRE POUV
                  ENTREE ENTIER VIRGULE ENTREE ENTIER VIRGULE ENTREE ENTIER VIRGULE ENTREE ENTIER
                  VIRGULE BI ENTIER VIRGULE BI ENTIER VIRGULE BI ENTIER VIRGULE BI ENTIER 
                  VIRGULE BI ENTIER VIRGULE BI ENTIER VIRGULE BI ENTIER VIRGULE BI ENTIER 
                  VIRGULE BI ENTIER
                  VIRGULE MONO ENTIER VIRGULE MONO ENTIER
                  VIRGULE TEMPO ENTIER
                  VIRGULE SORTIE ENTIER
                  VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER
                  VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER
                  VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER VIRGULE MSG ENTIER
                  VIRGULE MSG ENTIER VIRGULE MSG ENTIER
                  PFERM PVIRGULE
                {{ int taille;
                   char *instr;
                   taille = 300;
                   instr = New_chaine( taille );
                   g_snprintf( instr, taille, "Gerer_fenetre("
                                           "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,"
                                           "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d);",
                                            $5, $8, $11, $14, $17, $20, $23, $26, $29, $32, $35, $38, $41,
                                            $44, $47, $50, $53, $56, $59, $62, $65, $68, $71, $74, $77,
                                            $80, $83, $86, $89, $92, $95 );
                   Emettre( instr ); g_free(instr);
                }}
                ;

expr:           expr OU facteur
                {{ int taille;
                   taille = strlen($1)+strlen($3)+5;
                   $$ = New_chaine( taille );
                   g_snprintf( $$, taille, "%s || %s", $1, $3 );
                   g_free($1); g_free($3);
                }}

                | facteur
                ;
facteur:        facteur ET unite
                {{ int taille;
                   taille = strlen($1)+strlen($3)+7;
                   $$ = New_chaine( taille );
                   g_snprintf( $$, taille, "(%s && %s)", $1, $3 );
                   g_free($1); g_free($3);
                }}
                | unite
                ;

unite:          modulateur ENTIER HEURE ENTIER
                {{ int taille;
                   taille = 20;
                   $$ = New_chaine(taille);
                   if ($2>23) $2=23;
                   if ($4>59) $4=59;
                   switch ($1)
                    { case 0    : g_snprintf( $$, taille, "Heure(%d,%d)", $2, $4 );
                                  break;
                      case APRES: g_snprintf( $$, taille, "Heure_apres(%d,%d)", $2, $4 );
                                  break;
                      case AVANT: g_snprintf( $$, taille, "Heure_avant(%d,%d)", $2, $4 );
                                  break;
                    }
                }}
                | barre BI ENTIER
                {{ int taille;
                   struct ALIAS *alias;
                   alias = Get_alias_par_bit( BI, $3 );
                   if (!alias) { taille = 10;
                                 $$ = New_chaine( taille ); /* 10 caractères max */
                                 if ($1) g_snprintf( $$, taille, "!B(%d)", $3 );
                                    else g_snprintf( $$, taille, "B(%d)", $3 );
                               }
                          else { taille = strlen(alias->nom)+2;
                                 $$ = New_chaine( taille ); /* 10 caractères max */
                                 if ($1) g_snprintf( $$, taille, "!%s", alias->nom );
                                    else g_snprintf( $$, taille, "%s", alias->nom );
                               }
                }}
                | barre MONO ENTIER
                {{ int taille;
                   struct ALIAS *alias;
                   alias = Get_alias_par_bit( MONO, $3 );
                   if (!alias) { taille = 10;
                                 $$ = New_chaine( taille ); /* 10 caractères max */
                                 if ($1) g_snprintf( $$, taille, "!M(%d)", $3 );
                                    else g_snprintf( $$, taille, "M(%d)", $3 );
                               }
                          else { taille = strlen(alias->nom)+2;
                                 $$ = New_chaine( taille ); /* 10 caractères max */
                                 if ($1) g_snprintf( $$, taille, "!%s", alias->nom );
                                    else g_snprintf( $$, taille, "%s", alias->nom );
                               }
                }}
                | barre ENTREE ENTIER
                {{ int taille;
                   struct ALIAS *alias;
                   alias = Get_alias_par_bit( ENTREE, $3 );
                   if (!alias) { taille = 10;
                                 $$ = New_chaine( taille ); /* 10 caractères max */
                                 if ($1) g_snprintf( $$, taille, "!E(%d)", $3 );
                                    else g_snprintf( $$, taille, "E(%d)", $3 );
                               }
                          else { taille = strlen(alias->nom)+2;
                                 $$ = New_chaine( taille ); /* 10 caractères max */
                                 if ($1) g_snprintf( $$, taille, "!%s", alias->nom );
                                    else g_snprintf( $$, taille, "%s", alias->nom );
                               }
                }}
                | POUV expr PFERM
                {{ int taille;
                   taille = strlen($2)+3;
                   $$ = New_chaine( taille );
                   g_snprintf( $$, taille, "(%s)", $2 );
                   g_free($2);
                }}
                | barre TEMPO ENTIER
                {{ int taille;
                   if ($1) { taille = 15;
                             $$ = New_chaine( taille ); /* 10 caractères max */
                             g_snprintf( $$, taille, "TRbarre(%d)", $3 );
                           }
                      else { taille = 15;
                             $$ = New_chaine( taille ); /* 10 caractères max */
                             g_snprintf( $$, taille, "TR(%d)", $3 );
                           }
                }}
                | barre ID
                {{ struct ALIAS *alias;
                   char *chaine;
                   int taille;
                   alias = Get_alias_par_nom($2);                                /* On recupere l'alias */
                   if (alias)
                    { if (alias->bit == TEMPO)
                       { taille = 15;
                         $$ = New_chaine( taille ); /* 10 caractères max */
                         if (!$1) g_snprintf( $$, taille, "TR(%d)", alias->num );
                             else g_snprintf( $$, taille, "TRbarre(%d)", alias->num );
                       }
                      else
                       { switch(alias->bit) /* On traite que ce qui peut passer en "condition" */
                          { case ENTREE:
                            case BI    :
                            case MONO  : taille = strlen(alias->nom)+2;
                                         $$ = New_chaine( taille ); /* 10 caractères max */
                                         if (!$1) g_snprintf( $$, taille, "%s", alias->nom );
                                         else g_snprintf( $$, taille, "!%s", alias->nom );
                                         break;
                            default:     taille = strlen($2) + strlen(INTERDIT_GAUCHE) + 1;
                                         chaine = New_chaine(taille);
                                         g_snprintf(chaine, taille, INTERDIT_GAUCHE, ligne_source_dls, $2 );
                                         Emettre_erreur(chaine); g_free(chaine);
                                         erreur++;
                                         $$=New_chaine(2);
                                         g_snprintf( $$, 2, "0" );
                          }
                       }
                    }
                   else { taille = strlen($2) + strlen(NON_DEFINI) + 1;
                          chaine = New_chaine(taille);
                          g_snprintf(chaine, taille, NON_DEFINI, ligne_source_dls, $2 );
                          Emettre_erreur(chaine); g_free(chaine);
                          erreur++;
                          
                          $$=New_chaine(2);
                          g_snprintf( $$, 2, "0" );
                        }
                   g_free($2);                                     /* On n'a plus besoin de l'identifiant */
                }}
                ;
/********************************************* Gestion des actions ****************************************/
action:         action VIRGULE une_action
                {{ int taille;
                   $$=New_action();
                   taille = strlen($1->alors)+strlen($3->alors)+1;
                   $$->alors = New_chaine( taille );
                   g_snprintf( $$->alors, taille, "%s%s", $1->alors, $3->alors );
                   taille = 1;
                   if ($1->sinon) taille += strlen($1->sinon);
                   if ($3->sinon) taille += strlen($3->sinon);
                   if (taille>1)
                    { $$->sinon = New_chaine( taille );
                      if ($1->sinon && $3->sinon)
                       { g_snprintf( $$->sinon, taille, "%s%s", $1->sinon, $3->sinon ); }
                      else if ($1->sinon)
                       { g_snprintf( $$->sinon, taille, "%s", $1->sinon ); }
                      else
                       { g_snprintf( $$->sinon, taille, "%s", $3->sinon ); }
                    }
                   g_free($1->alors); if ($1->sinon) { g_free($1->sinon); }
                   g_free($3->alors); if ($3->sinon) { g_free($3->sinon); }
                   g_free($1); g_free($3);
                }}
                | une_action
                ;

une_action:     barre SORTIE ENTIER           {{ $$=New_action_sortie($3, $1);     }}
                | barre BI ENTIER             {{ $$=New_action_bi($3, $1);         }}
                | MONO ENTIER                 {{ $$=New_action_mono($2);           }}
                | ICONE ENTIER DPOINT ENTIER DPOINT couleur
                                              {{ $$=New_action_icone($2, $4, $6);  }}
                | TEMPO ENTIER DPOINT ENTIER  {{ $$=New_action_tempo($2, $4);      }}
                | MSG ENTIER                  {{ $$=New_action_msg($2);            }}
                | barre ID option_entier option_couleur
                {{ struct ALIAS *alias;                               /* Definition des actions via alias */
                   int taille;
                   alias = Get_alias_par_nom( $2 );
                   if (!alias)
                    { char *chaine;
                      taille = strlen($2) + strlen(NON_DEFINI) + 1;
                      chaine = New_chaine(taille);
                      g_snprintf( chaine, taille, NON_DEFINI, ligne_source_dls, $2 );
                      Emettre_erreur(chaine); g_free(chaine);
                      erreur++;

                      $$=New_action();
                      taille = 2;
                      $$->alors = New_chaine( taille );
                      g_snprintf( $$->alors, taille, " " ); 
                      $$->sinon = NULL;
                    }
                   else
                    { switch(alias->bit)
                       { case TEMPO : $$=New_action_tempo( alias->num, alias->consigne ); break;
                         case MSG   : $$=New_action_msg( alias->num );                    break;
                         case SORTIE: $$=New_action_sortie( alias->num, $1 );             break;
                         case BI    : $$=New_action_bi( alias->num, $1 );                 break;
                         case MONO  : $$=New_action_mono( alias->num );                   break;
                         case ICONE : $$=New_action_icone( alias->num, $3, $4 );          break;
                         default: { char *chaine;
                                    taille = strlen(alias->nom) + strlen(INTERDIT_DROITE) + 1;
                                    chaine = New_chaine(taille);
                                    g_snprintf( chaine, taille, INTERDIT_DROITE, ligne_source_dls, alias->nom );
                                    Emettre_erreur(chaine); g_free(chaine);
                                    erreur++;

                                    $$=New_action();
                                    taille = 2;
                                    $$->alors = New_chaine( taille );
                                    g_snprintf( $$->alors, taille, " " ); 
                                    $$->sinon = NULL;
                                  }
                       }
                    }
                   g_free($2);
                }}
                ;

barre:          BARRE {{ $$=1; }}
                |     {{ $$=0; }}
                ;

couleur:        ROUGE        {{ $$=ROUGE;  }}
                | VERT       {{ $$=VERT;   }}
                | BLEU       {{ $$=BLEU;   }}
                | JAUNE      {{ $$=JAUNE;  }}
                | NOIR       {{ $$=NOIR;   }}
                | BLANC      {{ $$=BLANC;  }}
                | GRIS       {{ $$=GRIS;   }}
                | ORANGE     {{ $$=ORANGE; }}
                ;
modulateur:     APRES        {{ $$=APRES;  }}
                | AVANT      {{ $$=AVANT;  }}
                |            {{ $$=0;      }}
                ;

option_entier:  DPOINT ENTIER  {{ $$=$2; }}
                |              {{ $$=0;  }}
                ;
option_couleur: DPOINT couleur  {{ $$=$2; }}
                |               {{ $$=0; }}
                ;
%%
/**********************************************************************************************************/
/* yyerror: Gestion des erreurs de syntaxe                                                                */
/**********************************************************************************************************/
 int Dls_error ( char *s )
  { int taille;
    char *chaine;
    taille = strlen(ERR_SYNTAXE) + strlen(s) + 5;
    chaine = New_chaine( taille );
    g_snprintf( chaine, taille, ERR_SYNTAXE, ligne_source_dls, s );
    Emettre_erreur( chaine );
    g_free(chaine);
    erreur++;
    return(0);
  }
/**********************************************************************************************************/
/* Interpreter: lecture et production de code intermedaire a partir du fichier en parametre               */
/* Entrée: le nom du fichier originel                                                                     */
/**********************************************************************************************************/
 gboolean Interpreter_source_dls ( gchar *source )
  { gchar chaine[80];
    gint retour;
    FILE *rc;

    ligne_source_dls  = 1;                                       /* Initialisation des variables globales */

    erreur=0;
    rc = fopen(source, "r");
    if (rc)
     { Emettre(" #include <Module_dls.h>\n void Go ( void )\n {\n");
       Dls_restart(rc);
       retour = Dls_parse();
       Emettre(" }\n");
       fclose(rc);
       if (erreur)
        { g_snprintf(chaine, sizeof(chaine), "%d error%c found\n", erreur, (retour>1 ? 'c' : ' ') );
          Emettre_erreur( chaine );
          return(FALSE);
        }
       return(TRUE);
     } else printf("ouverture plugin impossible: niet\n");
    return(FALSE);
  }
/*--------------------------------------------------------------------------------------------------------*/
